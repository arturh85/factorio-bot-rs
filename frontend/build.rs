use factorio_bot_backend::types::*;
use std::fs;
use std::path::Path;
use std::process::{Command, Stdio};
use typescript_definitions::TypeScriptifyTrait;

const TYPESCRIPT_MODELS_PATH: &str = "src/factorio-bot/types.ts";
const FRONTEND_PATH: &str = "./";

fn main() {
    typescriptify();
    npm_build();
}

fn typescriptify() {
    let existing =
        std::fs::read_to_string(TYPESCRIPT_MODELS_PATH).expect("types.ts does not exist?");
    let lines: Vec<&str> = existing.split('\n').collect();
    let autogenerated_marker = lines
        .iter()
        .position(|line| line.contains("AUTOGENERATED"))
        .expect("AUTOGENERATED marker not found");

    let mut output = String::from(&lines[0..autogenerated_marker + 1].join("\n")) + "\n";
    output += &FactorioFluidBoxPrototype::type_script_ify();
    output += &FactorioFluidBoxConnection::type_script_ify();
    output += &FactorioBlueprintInfo::type_script_ify();
    output += &PlayerChangedDistanceEvent::type_script_ify();
    output += &PlayerChangedPositionEvent::type_script_ify();
    output += &PlayerChangedMainInventoryEvent::type_script_ify();
    output += &PlayerLeftEvent::type_script_ify();
    output += &RequestEntity::type_script_ify();
    output += &FactorioTile::type_script_ify();
    output += &FactorioTechnology::type_script_ify();
    output += &FactorioForce::type_script_ify();
    output += &InventoryResponse::type_script_ify();
    output += &FactorioRecipe::type_script_ify();
    output += &PlaceEntityResult::type_script_ify();
    output += &PlaceEntitiesResult::type_script_ify();
    output += &FactorioIngredient::type_script_ify();
    output += &FactorioProduct::type_script_ify();
    output += &FactorioPlayer::type_script_ify();
    output += &ChunkPosition::type_script_ify();
    output += &Position::type_script_ify();
    output += &Rect::type_script_ify();
    output += &FactorioChunk::type_script_ify();
    output += &ChunkObject::type_script_ify();
    output += &ChunkResource::type_script_ify();
    output += &FactorioGraphic::type_script_ify();
    output += &FactorioEntity::type_script_ify();
    output += &FactorioEntityPrototype::type_script_ify();
    output += &FactorioItemPrototype::type_script_ify();
    output += &FactorioResult::type_script_ify();

    output = output.replace("DateTime<Utc>", "String");
    output = output.replace("DateTime<    Utc>", "String");
    output = output.replace("DateTime    <Utc>", "String");
    output = output.replace("NaiveDate", "String");
    output = output.replace("R64", "number");
    output = output.replace(": Value", ": object");
    output = output.replace("};", "};\n");
    while output.contains("  ") {
        output = output.replace("  ", " ");
    }
    output = output.replace("\n\n", "\n");
    fs::write(TYPESCRIPT_MODELS_PATH, output).expect("failed to write typescript types");
}

fn npm_build() {
    let npm_binary_path = which::which("npm");
    match npm_binary_path {
        Ok(npm_binary_path) => {
            let npm_binary_path = npm_binary_path.to_str().unwrap();
            let node_modules_path = format!("{}node_modules/", &FRONTEND_PATH);
            let node_modules_path = Path::new(&node_modules_path);
            if !node_modules_path.exists() {
                // npm ci
                let mut command = Command::new(npm_binary_path);
                command.args(&["ci"]).current_dir(FRONTEND_PATH);
                run_command(command);
            }
            // let dist_path = format!("{}dist/", &FRONTEND_PATH);
            // let dist_path = Path::new(&dist_path);
            // npm run build
            // if !dist_path.exists() {
            let mut command = Command::new(npm_binary_path);
            command.args(&["run", "build"]).current_dir(FRONTEND_PATH);
            run_command(command);
            // }
        }
        Err(err) => {
            eprintln!("npm binary not found!");
            panic!(err);
        }
    }
}

fn run_command(mut command: Command) {
    let status = command
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status();

    match status {
        Ok(exit_status) => {
            if exit_status.code().expect("failed to check exit status") > 0 {
                panic!("Failed to run {:?}", command);
            }
        }
        Err(err) => {
            eprintln!("{}", err);
            panic!("Failed to run {:?}", command);
        }
    }
}
